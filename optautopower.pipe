# This pipeline is going to calculate the power spectrum
#
# It supports multi maps. In this case, the result will
# be the average of each maps, and the error will be the 
# standard deviation of these maps.
#
# In the case of only one map, this pipeline will not 
# give the error, except you add the jeckknife module in.

import os
MAPPATH = os.getenv('MAPS')

pipe_modules = []
pipe_processes = 1

"""  setup some parameters  """
# Here we should include all the maps we are going to use in the 
NUM = 100 
#selection = 'selection'
selection = 'separable'

middlist = ('data', selection, 'rand')
filelist = []
lastlist = []
for ii in range(NUM):
	filelist.append('delta15')
	lastlist.append('%03d'%ii)
lastlist = tuple(lastlist)
filelist = tuple(filelist)

polarization = ('',)

# Here we set the directions about the maps and result
if selection=='selection':
	resultf = 'auto_15hr_opt_sel_eric'
	input_root = MAPPATH + 'binned_wiggleZ_optical_20111218/delta15hr/'
	output_root = '../optautopower_eric_sel/'
elif selection=='separable':
	resultf = 'auto_15hr_opt_sep_eric'
	input_root = MAPPATH + 'binned_wiggleZ_optical_20111218/delta15hrseparable/'
	output_root = '../optautopower_eric_sep/'

#output_root = '../optautopower_eric/'

#input_root = MAPPATH + 'binned_wiggleZ_optical_/delta15hr/'
#output_root = '../optautopower/'
#resultf = '15hr_opt_autopower'
#input_root = MAPPATH + 'binned_wiggleZ_optical_20111218/delta15hr/'
#output_root = '../optautopower_20111218/'
#resultf = '15hr_opt_autopower_20111218'

#FKPweight = True 
FKPweight = False  # Now we just use the noise weighted

# Set the k range
kmin = 0.07
kmax = 0.9
kbinNum = 15


# Set the maps used to calculate the short noise
pkc_hrlist = []
pkc_ltlist = []
for ii in range(NUM):
	pkc_hrlist.append(('delta15', 'delta15'))
	pkc_ltlist.append(('%03d'%ii, '%03d'%ii))
pkc_hrlist = tuple(pkc_hrlist)
pkc_ltlist = tuple(pkc_ltlist)
pkc_mid = ('rand', selection)
pkc_resultf = resultf+'_shortnoise'

# Set the data we are going to use for the calculation
wgz_hrlist = (
					('delta15','delta15'),
				 )
wgz_ltlist = (
					( '000', '000'),
				 )
# Set the maps used to calculate the jk noise
jm_hr = ('delta15',)
jm_last = ('000',)


""" Pipe line """
# I think you just need the 'prepare', 'mkpoer_combine' and 'plot' module
# If the plot module does not work well, you can plot yourself using the 
# output result 'PK_combined_' + resultf + '.npy' and 
# 'PKvar_combined' + resultf + '.npy'

''' prepare module is used to change the maps in to fftbox '''
#from mkpower import prepare
#pipe_modules.append(prepare.Prepare)

''' mkpower_combine is use to calculate the power spectrum '''
# Here we use this moduel to calculate the shortnoise and variance
#from mkpower import mkpower_combine
#pipe_modules.append(mkpower_combine.PowerSpectrumMaker)

''' mkpower_wiggleZ is use to calculate the optical auto power spectrum '''
#from mkpower import mkpower_wigglez
#pipe_modules.append(mkpower_wigglez.PowerSpectrumMaker)

''' make jackknife maps '''
#from mkpower import jkmap
#pipe_modules.append(jkmap.JackKnifeErrorMap)
#
#from mkpower import jkerror
#pipe_modules.append(jkerror.JackKnifeError)

''' pycamb is used to calculate the theoretical power spectrum using camb '''
#from mkpower import pycamb
#pipe_modules.append(pycamb.CAMB)

''' notlogplot is used to plot in not log axis '''
#from mkpower import notlogplot
#pipe_modules.append(notlogplot.PowerSpectrumPlot)

''' plot_single is used to plot the result '''
	#you can set its parameters at the very end of this file
 	#maybe the unit is always needed. It only support 'K' and 'mk'
 	#The 'ymin' will set the y low limit for the plot
 	#plot_single just plot the P(k).
 	#changing 'plot_single' to 'plot' will give a plot both P(k) and Delta(k)
from mkpower import plot_single
pipe_modules.append(plot_single.PowerSpectrumPlot)

''' bias is going to calculate the bias. '''
	#It need the simulation result 
#from mkpower import bias
#pipe_modules.append(bias.BiasCalibrate)
""" End """


"""  Peak remove : clean map -> pkrm clean map"""
#from mkpower import pkrm
#pipe_modules.append(pkrm.PeakRemove)
pr_processes = 1
pr_plot = False
#pr_plot = True
pr_input_root = input_root
pr_output_root = output_root
pr_hr = filelist
pr_mid = middlist
pr_polarizations = polarization
pr_last = lastlist

#filelist = ('pkrm_'+filelist[0], 'pkrm_'+filelist[1])

"""  Prepare """
#from mkpower import prepare
#pipe_modules.append(prepare.Prepare)
pre_processes = 5
pre_plot = False
#pre_plot = True
pre_input_root = input_root
pre_output_root = output_root
pre_hr = filelist
pre_mid = middlist
pre_polarizations = polarization
pre_last = lastlist

pre_boxshape = (512, 128, 64)
pre_discrete = 2
pre_boxunit = 2.
pre_Xrange = (1400, pre_boxunit*pre_boxshape[0]+1400)
pre_Yrange = (-pre_boxunit*pre_boxshape[1]*0.5, 
   	 		  pre_boxunit*pre_boxshape[1]*0.5)
pre_Zrange = (10.0, pre_boxunit*pre_boxshape[2]+10.0)
#pre_Zrange = (-pre_boxunit*pre_boxshape[2]*0.5,
#					pre_boxunit*pre_boxshape[2]*0.5)

"""  Add Noise to the Map"""


#from mkpower import noisemk
#pipe_modules.append(noisemk.MakeNoise)
nmk_processes = 3
nmk_plot = False
#nmk_plot = True
#nmk_input_root = input_root
#nmk_output_root = output_root
nmk_hr = filelist
nmk_mid = middlist
nmk_polarizations = polarization
#nmk_last = lastlist
nmk_sigma = 2.0
nmk_mu = 0.0

nmk_boxshape = (512, 128, 64)
nmk_discrete = 2
nmk_boxunit = 2.
nmk_Xrange = (1400, pre_boxunit*pre_boxshape[0]+1400)
nmk_Yrange = (-pre_boxunit*pre_boxshape[1]*0.5, 
   	 		  pre_boxunit*pre_boxshape[1]*0.5)
nmk_Zrange = (10.0, pre_boxunit*pre_boxshape[2]+10.0)


"""  Weight : clean map -> dirty map"""
#from mkpower import weight
#pipe_modules.append(weight.NoiseInversWeight)
wt_processes = 1
wt_plot = False
wt_input_root = pr_output_root
wt_output_root = output_root
wt_hr = filelist
wt_mid = middlist
wt_polarizations = polarization


"""  Calculate the Pk  """
#from mkpower import mkpower
#pipe_modules.append(mkpower.PowerSpectrumMaker)
pk_processes = 1
pk_plot = False 
#pk_plot = True
pk_saveweight = True
pk_input_root = wt_output_root
pk_output_root = output_root
pk_hr = filelist
pk_mid = middlist
pk_polarizations = polarization
pk_last = lastlist
pk_boxshape = pre_boxshape
pk_discrete = pre_discrete
pk_boxunit = pre_boxunit
pk_Xrange = pre_Xrange
pk_Yrange = pre_Yrange
pk_Zrange = pre_Zrange

pk_kbinNum = kbinNum

#pk_FKPweight = True
pk_FKPweight = FKPweight
pk_OmegaHI = 1.e-3
pk_Omegam = 0.24
pk_OmegaL = 0.76

"""  Calculate the wigglez Pk  """
#from mkpower import mkpower_wigglez
#pipe_modules.append(mkpower_wigglez.PowerSpectrumMaker)
wgz_processes = 3 
wgz_plot = False 
#wgz_plot = True
wgz_saveweight = True
wgz_input_root = wt_output_root
#wgz_input_root = input_root
wgz_output_root = output_root
wgz_hr = ()
wgz_mid = middlist
wgz_polarizations = polarization
wgz_last = ()
wgz_resultf = resultf
wgz_boxshape = pre_boxshape
wgz_discrete = pre_discrete
wgz_boxunit = pre_boxunit
wgz_Xrange = pre_Xrange
wgz_Yrange = pre_Yrange
wgz_Zrange = pre_Zrange

wgz_kbinNum = pk_kbinNum
wgz_kmin = kmin
wgz_kmax = kmax

#wgz_FKPweight = True
wgz_FKPweight = FKPweight
wgz_OmegaHI = 1.e-3
wgz_Omegam = 0.24
wgz_OmegaL = 0.76

wgz_sme = True

"""  Calculate the Cross Pk  """
#from mkpower import mkcrosspower
#pipe_modules.append(mkcrosspower.CrossPowerSpectrumMaker)
cpk_processes = 1
cpk_plot = False 
cpk_saveweight = True
cpk_input_root = wt_output_root
cpk_output_root = output_root
cpk_hr = filelist
cpk_mid = middlist
cpk_polarizations = polarization
cpk_last = lastlist
cpk_boxshape = (256, 64, 32)
cpk_discrete = 4
cpk_boxunit = 8.0
cpk_Xrange = (1400,)
cpk_Yrange = (-pk_boxunit*pk_boxshape[1]*0.5, 
				pk_boxunit*pk_boxshape[1]*0.5)
cpk_Zrange = (0.0, pk_boxunit*pk_boxshape[2])

#cpk_FKPweight = True
cpk_FKPweight = FKPweight
cpk_OmegaHI = 1.e-3
cpk_Omegam = 0.24
cpk_OmegaL = 0.76

"""  Calculate the combined Pk  """
#from mkpower import mkpower_combine
#pipe_modules.append(mkpower_combine.CrossPowerSpectrumMaker)
pkc_processes = 3
pkc_plot = False 
pkc_saveweight = True
pkc_input_root = wt_output_root
pkc_output_root = output_root
#pkc_resultf = resultf
pkc_hr = ()
#pkc_mid = middlist
pkc_polarizations = polarization
pkc_last = ()
pkc_boxshape = pre_boxshape
pkc_discrete = pre_discrete
pkc_boxunit = pre_boxunit
pkc_Xrange = pre_Xrange
pkc_Yrange = pre_Yrange
pkc_Zrange = pre_Zrange

pkc_kbinNum = pk_kbinNum 
pkc_kmin = kmin
pkc_kmax = kmax

#pkc_FKPweight = True
pkc_FKPweight = FKPweight
pkc_OmegaHI = 1.e-3
pkc_Omegam = 0.24
pkc_OmegaL = 0.76

pkc_sme = False  # sample mean error

"""  Calling CAMB """
#from mkpower import pycamb
#pipe_modules.append(pycamb.CAMB)
pcb_output_root = output_root+"cambio/"
pcb_do_nonlinear = 1
pcb_transfer_redshift = 0.6
pcb_transfer_high_precision = 'T'
pcb_transfer_kmax = 1.5
#pcb_transfer_k_per_logint = 400

"""  Calculate the WindowF  """
#from mkpower import windowf
#pipe_modules.append(windowf.WindowFunctionMaker)
wd_processes = 1
#wd_plot = False
wd_plot = True
wd_input_root = wt_output_root
wd_output_root = output_root
wd_hr = filelist
wd_mid = middlist
wd_polarizations = polarization
wd_last = lastlist
wd_boxshape = pk_boxshape
wd_boxunit = pk_boxunit
wd_FKPweight = FKPweight
wd_discrete = 2
wd_Xrange = (1400, pk_boxunit*pk_boxshape[0]+1400)
wd_Yrange = (-pk_boxunit*pk_boxshape[1]*0.5, 
              pk_boxunit*pk_boxshape[1]*0.5)
wd_Zrange = (0.0, pk_boxunit*pk_boxshape[2])

"""  Calculate the nonlinear Power Spectrum  """
#from mkpower import nonlpower
#pipe_modules.append(nonlpower.TheoryPowerSpectrumMaker)
nl_processes = 1
nl_plot = True
#nl_plot = False
nl_hr = filelist
nl_mid = middlist
nl_polarizations = polarization
nl_last = lastlist
nl_input_root = input_root
nl_camb_input_root = pcb_output_root
nl_output_root = output_root
#nl_boxshape = pk_boxshape
#nl_boxunit = pk_boxunit
nl_boxshape = (256, 256, 256)
nl_boxunit = 32.
nl_boxshapelist = ((256,256,256),(256,256,256))
nl_boxunitlist = (32.0, 8.0)
nl_FKPweight = FKPweight
nl_discrete = 2
nl_Xrange = (1400, pk_boxunit*pk_boxshape[0]+1400)
nl_Yrange = (-pk_boxunit*pk_boxshape[1]*0.5, 
              pk_boxunit*pk_boxshape[1]*0.5)
nl_Zrange = (0.0, pk_boxunit*pk_boxshape[2])

nl_OmegaHI = 1.e-3
nl_Omegam = 0.24
nl_OmegaL = 0.76
nl_z = 1.


""" Calibrate the Bias of the Power Spectrum  """
#form mkpower import bias
#pipe_modules.append(bias.BiasCalibrate)
bc_processes = 1
bc_plot = True
bc_input_root = output_root
bc_output_root = bc_input_root
bc_resultf = resultf
bc_PKunit = 'mK'


""" Window Function Plot """
#from mkpower import plot
#pipe_modules.append(plot.PowerSpectrumPlot)
wpt_processes = 1
wpt_input_root = nl_output_root
wpt_hr = filelist
wpt_last = lastlist
wpt_output_root = output_root
wpt_FKPweight = True
wpt_boxshape = ((256,256,256), (256,256,256))
wpt_boxunit = (8.0, 32.0)


"""  Make JackKnife Map """
#from mkpower import jkmap
#pipe_modules.append(jkmap.JackKnifeErrorMap)
jm_processes = 4
jm_plot = False
jm_input_root = input_root
jm_jkn0 = 8
jm_jkn1 = 4
jm_jkn2 = 4
#jm_hr = filelist
jm_mid = middlist
jm_polarizations = polarization
#jm_last = lastlist
jm_output_root = output_root + 'jkmap/'
jm_boxshape = pre_boxshape
jm_discrete = pre_discrete
jm_boxunit = pre_boxunit
jm_Xrange = pre_Xrange
jm_Yrange = pre_Yrange
jm_Zrange = pre_Zrange


"""  Calculate the jk error (Better run in mpi)"""
#from mkpower import jkerror
#pipe_modules.append(jkerror.JackKnifeError)
jk_jknumber = jm_jkn0*jm_jkn1*jm_jkn2
jk_hrlist = []
jk_ltlist = []
for ii in range(jk_jknumber):
	a1 = wgz_hrlist[0][0]+'jk%03d'%ii
	a2 = wgz_hrlist[0][1]+'jk%03d'%ii
	jk_hrlist.append((a1, a2))
	b1 = wgz_ltlist[0][0]
	b2 = wgz_ltlist[0][1]
	jk_ltlist.append((b1, b2))
jk_hrlist = tuple(jk_hrlist)
jk_ltlist = tuple(jk_ltlist)
#print jk_hrlist
#print jk_ltlist

jk_kmin = kmin
jk_kmax = kmax
jk_processes = 4
jk_plot = False
jk_input_root = jm_output_root
jk_hr = filelist
jk_mid = middlist
jk_polarizations = polarization
jk_last = lastlist
jk_output_root = output_root
jk_boxshape = pk_boxshape
jk_discrete = pk_discrete
jk_boxunit = pk_boxunit
jk_Xrange = pk_Xrange
jk_Yrange = pk_Yrange
jk_Zrange = pk_Zrange
jk_kbinNum = pk_kbinNum
jk_resultf = resultf

#jk_FKPweight = False
jk_FKPweight = pk_FKPweight
jk_OmegaHI = 1.e-3
jk_Omegam = 0.24
jk_OmegaL = 0.76
jk_z = 1.


"""  Plot  """
#from mkpower import plot_single
#pipe_modules.append(plot_single.PowerSpectrumPlot)
pt_processes = 1
pt_input_root = jk_output_root
pt_hr = filelist
pt_last = lastlist
pt_output_root = output_root
pt_FKPweight = FKPweight
pt_OmegaHI = 1.e-3
pt_Omegam = 0.24
pt_OmegaL = 0.76
pt_z = 0.6
pt_ymin = 1.e-2
pt_ymax = 1.e2
pt_PKunit = 'mK'
pt_resultf = resultf
pt_kmin = pkc_kmin
#pt_kmin = 0.15
pt_kmax = pkc_kmax
pt_optical = True

